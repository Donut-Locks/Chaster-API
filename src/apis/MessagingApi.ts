/* tslint:disable */
/* eslint-disable */
/**
 * Chaster
 * Chaster Public API  API documentation: [https://docs.chaster.app/api-introduction](https://docs.chaster.app/api-introduction) 
 *
 * The version of the OpenAPI document: 0.12.54
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ConversationForPublic,
  CreateConversationDto,
  GetConversationsRepDto,
  GetMessagesRepDto,
  MessageForPublic,
  SetConversationStatusDto,
  SetConversationUnreadDto,
  UpdateConversationDto,
} from '../models';
import {
    ConversationForPublicFromJSON,
    ConversationForPublicToJSON,
    CreateConversationDtoFromJSON,
    CreateConversationDtoToJSON,
    GetConversationsRepDtoFromJSON,
    GetConversationsRepDtoToJSON,
    GetMessagesRepDtoFromJSON,
    GetMessagesRepDtoToJSON,
    MessageForPublicFromJSON,
    MessageForPublicToJSON,
    SetConversationStatusDtoFromJSON,
    SetConversationStatusDtoToJSON,
    SetConversationUnreadDtoFromJSON,
    SetConversationUnreadDtoToJSON,
    UpdateConversationDtoFromJSON,
    UpdateConversationDtoToJSON,
} from '../models';

export interface MessagingControllerCreateConversationRequest {
    createConversationDto: CreateConversationDto;
}

export interface MessagingControllerGetConversationRequest {
    conversationId: string;
}

export interface MessagingControllerGetConversationByUserIdRequest {
    userId: string;
}

export interface MessagingControllerGetConversationsRequest {
    limit?: number;
    status?: MessagingControllerGetConversationsStatusEnum;
    offset?: Date;
}

export interface MessagingControllerGetMessagesRequest {
    conversationId: string;
    limit?: number;
    lastId?: string;
}

export interface MessagingControllerSendMessageRequest {
    conversationId: string;
    updateConversationDto: UpdateConversationDto;
}

export interface MessagingControllerSetConversationStatusRequest {
    conversationId: string;
    setConversationStatusDto: SetConversationStatusDto;
}

export interface MessagingControllerSetConversationUnreadRequest {
    conversationId: string;
    setConversationUnreadDto: SetConversationUnreadDto;
}

/**
 * 
 */
export class MessagingApi extends runtime.BaseAPI {

    /**
     * Creates a conversation
     * Create a conversation
     */
    async messagingControllerCreateConversationRaw(requestParameters: MessagingControllerCreateConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationForPublic>> {
        if (requestParameters.createConversationDto === null || requestParameters.createConversationDto === undefined) {
            throw new runtime.RequiredError('createConversationDto','Required parameter requestParameters.createConversationDto was null or undefined when calling messagingControllerCreateConversation.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["messaging"]);
        }

        const response = await this.request({
            path: `/conversations`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateConversationDtoToJSON(requestParameters.createConversationDto),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationForPublicFromJSON(jsonValue));
    }

    /**
     * Creates a conversation
     * Create a conversation
     */
    async messagingControllerCreateConversation(requestParameters: MessagingControllerCreateConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationForPublic> {
        const response = await this.messagingControllerCreateConversationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Finds a conversation
     * Find a conversation
     */
    async messagingControllerGetConversationRaw(requestParameters: MessagingControllerGetConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationForPublic>> {
        if (requestParameters.conversationId === null || requestParameters.conversationId === undefined) {
            throw new runtime.RequiredError('conversationId','Required parameter requestParameters.conversationId was null or undefined when calling messagingControllerGetConversation.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["messaging"]);
        }

        const response = await this.request({
            path: `/conversations/{conversationId}`.replace(`{${"conversationId"}}`, encodeURIComponent(String(requestParameters.conversationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationForPublicFromJSON(jsonValue));
    }

    /**
     * Finds a conversation
     * Find a conversation
     */
    async messagingControllerGetConversation(requestParameters: MessagingControllerGetConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationForPublic> {
        const response = await this.messagingControllerGetConversationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Finds a conversation by user id
     * Find conversation by user id
     */
    async messagingControllerGetConversationByUserIdRaw(requestParameters: MessagingControllerGetConversationByUserIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationForPublic>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling messagingControllerGetConversationByUserId.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["messaging"]);
        }

        const response = await this.request({
            path: `/conversations/by-user/{userId}`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationForPublicFromJSON(jsonValue));
    }

    /**
     * Finds a conversation by user id
     * Find conversation by user id
     */
    async messagingControllerGetConversationByUserId(requestParameters: MessagingControllerGetConversationByUserIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationForPublic> {
        const response = await this.messagingControllerGetConversationByUserIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Finds a list of conversations
     * Find a list of conversations
     */
    async messagingControllerGetConversationsRaw(requestParameters: MessagingControllerGetConversationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetConversationsRepDto>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.status !== undefined) {
            queryParameters['status'] = requestParameters.status;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = (requestParameters.offset as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["messaging"]);
        }

        const response = await this.request({
            path: `/conversations`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetConversationsRepDtoFromJSON(jsonValue));
    }

    /**
     * Finds a list of conversations
     * Find a list of conversations
     */
    async messagingControllerGetConversations(requestParameters: MessagingControllerGetConversationsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetConversationsRepDto> {
        const response = await this.messagingControllerGetConversationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Finds messages in a conversation
     * Find messages in a conversation
     */
    async messagingControllerGetMessagesRaw(requestParameters: MessagingControllerGetMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetMessagesRepDto>> {
        if (requestParameters.conversationId === null || requestParameters.conversationId === undefined) {
            throw new runtime.RequiredError('conversationId','Required parameter requestParameters.conversationId was null or undefined when calling messagingControllerGetMessages.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.lastId !== undefined) {
            queryParameters['lastId'] = requestParameters.lastId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["messaging"]);
        }

        const response = await this.request({
            path: `/conversations/{conversationId}/messages`.replace(`{${"conversationId"}}`, encodeURIComponent(String(requestParameters.conversationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetMessagesRepDtoFromJSON(jsonValue));
    }

    /**
     * Finds messages in a conversation
     * Find messages in a conversation
     */
    async messagingControllerGetMessages(requestParameters: MessagingControllerGetMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetMessagesRepDto> {
        const response = await this.messagingControllerGetMessagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a conversation
     * Add a new message in a conversation
     */
    async messagingControllerSendMessageRaw(requestParameters: MessagingControllerSendMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageForPublic>> {
        if (requestParameters.conversationId === null || requestParameters.conversationId === undefined) {
            throw new runtime.RequiredError('conversationId','Required parameter requestParameters.conversationId was null or undefined when calling messagingControllerSendMessage.');
        }

        if (requestParameters.updateConversationDto === null || requestParameters.updateConversationDto === undefined) {
            throw new runtime.RequiredError('updateConversationDto','Required parameter requestParameters.updateConversationDto was null or undefined when calling messagingControllerSendMessage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["messaging"]);
        }

        const response = await this.request({
            path: `/conversations/{conversationId}`.replace(`{${"conversationId"}}`, encodeURIComponent(String(requestParameters.conversationId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateConversationDtoToJSON(requestParameters.updateConversationDto),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MessageForPublicFromJSON(jsonValue));
    }

    /**
     * Updates a conversation
     * Add a new message in a conversation
     */
    async messagingControllerSendMessage(requestParameters: MessagingControllerSendMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageForPublic> {
        const response = await this.messagingControllerSendMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a conversation status
     * Set a conversation status
     */
    async messagingControllerSetConversationStatusRaw(requestParameters: MessagingControllerSetConversationStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.conversationId === null || requestParameters.conversationId === undefined) {
            throw new runtime.RequiredError('conversationId','Required parameter requestParameters.conversationId was null or undefined when calling messagingControllerSetConversationStatus.');
        }

        if (requestParameters.setConversationStatusDto === null || requestParameters.setConversationStatusDto === undefined) {
            throw new runtime.RequiredError('setConversationStatusDto','Required parameter requestParameters.setConversationStatusDto was null or undefined when calling messagingControllerSetConversationStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["messaging"]);
        }

        const response = await this.request({
            path: `/conversations/{conversationId}/status`.replace(`{${"conversationId"}}`, encodeURIComponent(String(requestParameters.conversationId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SetConversationStatusDtoToJSON(requestParameters.setConversationStatusDto),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates a conversation status
     * Set a conversation status
     */
    async messagingControllerSetConversationStatus(requestParameters: MessagingControllerSetConversationStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.messagingControllerSetConversationStatusRaw(requestParameters, initOverrides);
    }

    /**
     * Updates a conversation unread status
     * Set a conversation unread status
     */
    async messagingControllerSetConversationUnreadRaw(requestParameters: MessagingControllerSetConversationUnreadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.conversationId === null || requestParameters.conversationId === undefined) {
            throw new runtime.RequiredError('conversationId','Required parameter requestParameters.conversationId was null or undefined when calling messagingControllerSetConversationUnread.');
        }

        if (requestParameters.setConversationUnreadDto === null || requestParameters.setConversationUnreadDto === undefined) {
            throw new runtime.RequiredError('setConversationUnreadDto','Required parameter requestParameters.setConversationUnreadDto was null or undefined when calling messagingControllerSetConversationUnread.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["messaging"]);
        }

        const response = await this.request({
            path: `/conversations/{conversationId}/unread`.replace(`{${"conversationId"}}`, encodeURIComponent(String(requestParameters.conversationId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SetConversationUnreadDtoToJSON(requestParameters.setConversationUnreadDto),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates a conversation unread status
     * Set a conversation unread status
     */
    async messagingControllerSetConversationUnread(requestParameters: MessagingControllerSetConversationUnreadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.messagingControllerSetConversationUnreadRaw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const MessagingControllerGetConversationsStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Ignored: 'ignored'
} as const;
export type MessagingControllerGetConversationsStatusEnum = typeof MessagingControllerGetConversationsStatusEnum[keyof typeof MessagingControllerGetConversationsStatusEnum];
