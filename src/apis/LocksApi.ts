/* tslint:disable */
/* eslint-disable */
/**
 * Chaster
 * Chaster Public API  API documentation: [https://docs.chaster.app/api-introduction](https://docs.chaster.app/api-introduction) 
 *
 * The version of the OpenAPI document: 0.12.54
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CombinationForPublic,
  GetHistoryRepDto,
  GetLockHistoryDto,
  GetLockInfoFromExtensionRepDto,
  IncreaseMaxLimitDateDto,
  LockControllerSetMaxLimitDate400Response,
  LockControllerTrustKeyholder400Response,
  LockForPublic,
  SetFreezeDto,
  SetLockSettingsDto,
  TriggerExtensionActionDto,
  UpdateTimeDto,
} from '../models';
import {
    CombinationForPublicFromJSON,
    CombinationForPublicToJSON,
    GetHistoryRepDtoFromJSON,
    GetHistoryRepDtoToJSON,
    GetLockHistoryDtoFromJSON,
    GetLockHistoryDtoToJSON,
    GetLockInfoFromExtensionRepDtoFromJSON,
    GetLockInfoFromExtensionRepDtoToJSON,
    IncreaseMaxLimitDateDtoFromJSON,
    IncreaseMaxLimitDateDtoToJSON,
    LockControllerSetMaxLimitDate400ResponseFromJSON,
    LockControllerSetMaxLimitDate400ResponseToJSON,
    LockControllerTrustKeyholder400ResponseFromJSON,
    LockControllerTrustKeyholder400ResponseToJSON,
    LockForPublicFromJSON,
    LockForPublicToJSON,
    SetFreezeDtoFromJSON,
    SetFreezeDtoToJSON,
    SetLockSettingsDtoFromJSON,
    SetLockSettingsDtoToJSON,
    TriggerExtensionActionDtoFromJSON,
    TriggerExtensionActionDtoToJSON,
    UpdateTimeDtoFromJSON,
    UpdateTimeDtoToJSON,
} from '../models';

export interface LockControllerArchiveRequest {
    lockId: string;
}

export interface LockControllerArchiveKeyholderRequest {
    lockId: string;
}

export interface LockControllerCombinationRequest {
    lockId: string;
}

export interface LockControllerFindAllRequest {
    status?: LockControllerFindAllStatusEnum;
}

export interface LockControllerFindOneRequest {
    lockId: string;
}

export interface LockControllerGetLockHistoryRequest {
    lockId: string;
    getLockHistoryDto: GetLockHistoryDto;
}

export interface LockControllerSetFreezeRequest {
    lockId: string;
    setFreezeDto: SetFreezeDto;
}

export interface LockControllerSetMaxLimitDateRequest {
    lockId: string;
    increaseMaxLimitDateDto: IncreaseMaxLimitDateDto;
}

export interface LockControllerSetSettingsRequest {
    lockId: string;
    setLockSettingsDto: SetLockSettingsDto;
}

export interface LockControllerTrustKeyholderRequest {
    lockId: string;
}

export interface LockControllerUnlockRequest {
    lockId: string;
}

export interface LockControllerUpdateTimeRequest {
    lockId: string;
    updateTimeDto: UpdateTimeDto;
}

export interface LockExtensionControllerGetLockInfoFromExtensionRequest {
    extensionId: string;
    lockId: string;
}

export interface LockExtensionControllerTriggerActionRequest {
    extensionId: string;
    lockId: string;
    triggerExtensionActionDto: TriggerExtensionActionDto;
}

/**
 * 
 */
export class LocksApi extends runtime.BaseAPI {

    /**
     * Archives a lock as a wearer. A wearer can archive its own lock: <ul> <li>If the lock is running (status `locked`), the lock will become deserted (status `deserted`), with no possibility of going back.</li> <li>If the lock is unlocked, the lock will simply be archived.</li> </ul>
     * Archive a lock
     */
    async lockControllerArchiveRaw(requestParameters: LockControllerArchiveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.lockId === null || requestParameters.lockId === undefined) {
            throw new runtime.RequiredError('lockId','Required parameter requestParameters.lockId was null or undefined when calling lockControllerArchive.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["locks"]);
        }

        const response = await this.request({
            path: `/locks/{lockId}/archive`.replace(`{${"lockId"}}`, encodeURIComponent(String(requestParameters.lockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Archives a lock as a wearer. A wearer can archive its own lock: <ul> <li>If the lock is running (status `locked`), the lock will become deserted (status `deserted`), with no possibility of going back.</li> <li>If the lock is unlocked, the lock will simply be archived.</li> </ul>
     * Archive a lock
     */
    async lockControllerArchive(requestParameters: LockControllerArchiveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.lockControllerArchiveRaw(requestParameters, initOverrides);
    }

    /**
     * Archives a lock as a keyholder. Keyholders can use this endpoint to archive unlocked locks.
     * Archive a lock as a keyholder
     */
    async lockControllerArchiveKeyholderRaw(requestParameters: LockControllerArchiveKeyholderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.lockId === null || requestParameters.lockId === undefined) {
            throw new runtime.RequiredError('lockId','Required parameter requestParameters.lockId was null or undefined when calling lockControllerArchiveKeyholder.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["locks"]);
        }

        const response = await this.request({
            path: `/locks/{lockId}/archive/keyholder`.replace(`{${"lockId"}}`, encodeURIComponent(String(requestParameters.lockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Archives a lock as a keyholder. Keyholders can use this endpoint to archive unlocked locks.
     * Archive a lock as a keyholder
     */
    async lockControllerArchiveKeyholder(requestParameters: LockControllerArchiveKeyholderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.lockControllerArchiveKeyholderRaw(requestParameters, initOverrides);
    }

    /**
     * Finds a lock combination
     * Find a lock combination
     */
    async lockControllerCombinationRaw(requestParameters: LockControllerCombinationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CombinationForPublic>> {
        if (requestParameters.lockId === null || requestParameters.lockId === undefined) {
            throw new runtime.RequiredError('lockId','Required parameter requestParameters.lockId was null or undefined when calling lockControllerCombination.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["locks"]);
        }

        const response = await this.request({
            path: `/locks/{lockId}/combination`.replace(`{${"lockId"}}`, encodeURIComponent(String(requestParameters.lockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CombinationForPublicFromJSON(jsonValue));
    }

    /**
     * Finds a lock combination
     * Find a lock combination
     */
    async lockControllerCombination(requestParameters: LockControllerCombinationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CombinationForPublic> {
        const response = await this.lockControllerCombinationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of all user locks  By default, only active locks are returned.
     * Get user locks
     */
    async lockControllerFindAllRaw(requestParameters: LockControllerFindAllRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<LockForPublic>>> {
        const queryParameters: any = {};

        if (requestParameters.status !== undefined) {
            queryParameters['status'] = requestParameters.status;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["locks"]);
        }

        const response = await this.request({
            path: `/locks`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(LockForPublicFromJSON));
    }

    /**
     * Returns a list of all user locks  By default, only active locks are returned.
     * Get user locks
     */
    async lockControllerFindAll(requestParameters: LockControllerFindAllRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<LockForPublic>> {
        const response = await this.lockControllerFindAllRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a lock by id
     * Get a lock by id
     */
    async lockControllerFindOneRaw(requestParameters: LockControllerFindOneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LockForPublic>> {
        if (requestParameters.lockId === null || requestParameters.lockId === undefined) {
            throw new runtime.RequiredError('lockId','Required parameter requestParameters.lockId was null or undefined when calling lockControllerFindOne.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["locks"]);
        }

        const response = await this.request({
            path: `/locks/{lockId}`.replace(`{${"lockId"}}`, encodeURIComponent(String(requestParameters.lockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LockForPublicFromJSON(jsonValue));
    }

    /**
     * Returns a lock by id
     * Get a lock by id
     */
    async lockControllerFindOne(requestParameters: LockControllerFindOneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LockForPublic> {
        const response = await this.lockControllerFindOneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of action logs
     * Return lock history
     */
    async lockControllerGetLockHistoryRaw(requestParameters: LockControllerGetLockHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetHistoryRepDto>> {
        if (requestParameters.lockId === null || requestParameters.lockId === undefined) {
            throw new runtime.RequiredError('lockId','Required parameter requestParameters.lockId was null or undefined when calling lockControllerGetLockHistory.');
        }

        if (requestParameters.getLockHistoryDto === null || requestParameters.getLockHistoryDto === undefined) {
            throw new runtime.RequiredError('getLockHistoryDto','Required parameter requestParameters.getLockHistoryDto was null or undefined when calling lockControllerGetLockHistory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["locks"]);
        }

        const response = await this.request({
            path: `/locks/{lockId}/history`.replace(`{${"lockId"}}`, encodeURIComponent(String(requestParameters.lockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GetLockHistoryDtoToJSON(requestParameters.getLockHistoryDto),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetHistoryRepDtoFromJSON(jsonValue));
    }

    /**
     * Returns a list of action logs
     * Return lock history
     */
    async lockControllerGetLockHistory(requestParameters: LockControllerGetLockHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetHistoryRepDto> {
        const response = await this.lockControllerGetLockHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Freezes a lock. Keyholders can use this endpoint to freeze wearer\'s locks.
     * Freeze a lock
     */
    async lockControllerSetFreezeRaw(requestParameters: LockControllerSetFreezeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.lockId === null || requestParameters.lockId === undefined) {
            throw new runtime.RequiredError('lockId','Required parameter requestParameters.lockId was null or undefined when calling lockControllerSetFreeze.');
        }

        if (requestParameters.setFreezeDto === null || requestParameters.setFreezeDto === undefined) {
            throw new runtime.RequiredError('setFreezeDto','Required parameter requestParameters.setFreezeDto was null or undefined when calling lockControllerSetFreeze.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["locks"]);
        }

        const response = await this.request({
            path: `/locks/{lockId}/freeze`.replace(`{${"lockId"}}`, encodeURIComponent(String(requestParameters.lockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SetFreezeDtoToJSON(requestParameters.setFreezeDto),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Freezes a lock. Keyholders can use this endpoint to freeze wearer\'s locks.
     * Freeze a lock
     */
    async lockControllerSetFreeze(requestParameters: LockControllerSetFreezeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.lockControllerSetFreezeRaw(requestParameters, initOverrides);
    }

    /**
     * Increase the max limit date. Only the wearer can increase the limit.
     * Increase the max limit date
     */
    async lockControllerSetMaxLimitDateRaw(requestParameters: LockControllerSetMaxLimitDateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.lockId === null || requestParameters.lockId === undefined) {
            throw new runtime.RequiredError('lockId','Required parameter requestParameters.lockId was null or undefined when calling lockControllerSetMaxLimitDate.');
        }

        if (requestParameters.increaseMaxLimitDateDto === null || requestParameters.increaseMaxLimitDateDto === undefined) {
            throw new runtime.RequiredError('increaseMaxLimitDateDto','Required parameter requestParameters.increaseMaxLimitDateDto was null or undefined when calling lockControllerSetMaxLimitDate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["locks"]);
        }

        const response = await this.request({
            path: `/locks/{lockId}/max-limit-date`.replace(`{${"lockId"}}`, encodeURIComponent(String(requestParameters.lockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IncreaseMaxLimitDateDtoToJSON(requestParameters.increaseMaxLimitDateDto),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Increase the max limit date. Only the wearer can increase the limit.
     * Increase the max limit date
     */
    async lockControllerSetMaxLimitDate(requestParameters: LockControllerSetMaxLimitDateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.lockControllerSetMaxLimitDateRaw(requestParameters, initOverrides);
    }

    /**
     * Update locks settings. Only the keyholder can update lock settings.
     * Update lock settings
     */
    async lockControllerSetSettingsRaw(requestParameters: LockControllerSetSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.lockId === null || requestParameters.lockId === undefined) {
            throw new runtime.RequiredError('lockId','Required parameter requestParameters.lockId was null or undefined when calling lockControllerSetSettings.');
        }

        if (requestParameters.setLockSettingsDto === null || requestParameters.setLockSettingsDto === undefined) {
            throw new runtime.RequiredError('setLockSettingsDto','Required parameter requestParameters.setLockSettingsDto was null or undefined when calling lockControllerSetSettings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["locks"]);
        }

        const response = await this.request({
            path: `/locks/{lockId}/settings`.replace(`{${"lockId"}}`, encodeURIComponent(String(requestParameters.lockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SetLockSettingsDtoToJSON(requestParameters.setLockSettingsDto),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update locks settings. Only the keyholder can update lock settings.
     * Update lock settings
     */
    async lockControllerSetSettings(requestParameters: LockControllerSetSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.lockControllerSetSettingsRaw(requestParameters, initOverrides);
    }

    /**
     * Trust the keyholder. Only the wearer can trust the keyholder.
     * Trust the keyholder
     */
    async lockControllerTrustKeyholderRaw(requestParameters: LockControllerTrustKeyholderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.lockId === null || requestParameters.lockId === undefined) {
            throw new runtime.RequiredError('lockId','Required parameter requestParameters.lockId was null or undefined when calling lockControllerTrustKeyholder.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["locks"]);
        }

        const response = await this.request({
            path: `/locks/{lockId}/trust-keyholder`.replace(`{${"lockId"}}`, encodeURIComponent(String(requestParameters.lockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Trust the keyholder. Only the wearer can trust the keyholder.
     * Trust the keyholder
     */
    async lockControllerTrustKeyholder(requestParameters: LockControllerTrustKeyholderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.lockControllerTrustKeyholderRaw(requestParameters, initOverrides);
    }

    /**
     * Unlocks a lock. For wearers, the lock must respect certain constraints so that it can be unlocked.
     * Unlock a lock
     */
    async lockControllerUnlockRaw(requestParameters: LockControllerUnlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.lockId === null || requestParameters.lockId === undefined) {
            throw new runtime.RequiredError('lockId','Required parameter requestParameters.lockId was null or undefined when calling lockControllerUnlock.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["locks"]);
        }

        const response = await this.request({
            path: `/locks/{lockId}/unlock`.replace(`{${"lockId"}}`, encodeURIComponent(String(requestParameters.lockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Unlocks a lock. For wearers, the lock must respect certain constraints so that it can be unlocked.
     * Unlock a lock
     */
    async lockControllerUnlock(requestParameters: LockControllerUnlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.lockControllerUnlockRaw(requestParameters, initOverrides);
    }

    /**
     * Adds or removes duration to a lock. Keyholders can add or remove time, while wearers can only add time.
     * Update lock duration
     */
    async lockControllerUpdateTimeRaw(requestParameters: LockControllerUpdateTimeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.lockId === null || requestParameters.lockId === undefined) {
            throw new runtime.RequiredError('lockId','Required parameter requestParameters.lockId was null or undefined when calling lockControllerUpdateTime.');
        }

        if (requestParameters.updateTimeDto === null || requestParameters.updateTimeDto === undefined) {
            throw new runtime.RequiredError('updateTimeDto','Required parameter requestParameters.updateTimeDto was null or undefined when calling lockControllerUpdateTime.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["locks"]);
        }

        const response = await this.request({
            path: `/locks/{lockId}/update-time`.replace(`{${"lockId"}}`, encodeURIComponent(String(requestParameters.lockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateTimeDtoToJSON(requestParameters.updateTimeDto),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Adds or removes duration to a lock. Keyholders can add or remove time, while wearers can only add time.
     * Update lock duration
     */
    async lockControllerUpdateTime(requestParameters: LockControllerUpdateTimeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.lockControllerUpdateTimeRaw(requestParameters, initOverrides);
    }

    /**
     * 
     * Get information from an extension for a given lock
     */
    async lockExtensionControllerGetLockInfoFromExtensionRaw(requestParameters: LockExtensionControllerGetLockInfoFromExtensionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetLockInfoFromExtensionRepDto>> {
        if (requestParameters.extensionId === null || requestParameters.extensionId === undefined) {
            throw new runtime.RequiredError('extensionId','Required parameter requestParameters.extensionId was null or undefined when calling lockExtensionControllerGetLockInfoFromExtension.');
        }

        if (requestParameters.lockId === null || requestParameters.lockId === undefined) {
            throw new runtime.RequiredError('lockId','Required parameter requestParameters.lockId was null or undefined when calling lockExtensionControllerGetLockInfoFromExtension.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request({
            path: `/locks/{lockId}/extensions/{extensionId}`.replace(`{${"extensionId"}}`, encodeURIComponent(String(requestParameters.extensionId))).replace(`{${"lockId"}}`, encodeURIComponent(String(requestParameters.lockId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetLockInfoFromExtensionRepDtoFromJSON(jsonValue));
    }

    /**
     * 
     * Get information from an extension for a given lock
     */
    async lockExtensionControllerGetLockInfoFromExtension(requestParameters: LockExtensionControllerGetLockInfoFromExtensionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetLockInfoFromExtensionRepDto> {
        const response = await this.lockExtensionControllerGetLockInfoFromExtensionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Triggers an action in a lock extension
     * Trigger an action for a lock extension
     */
    async lockExtensionControllerTriggerActionRaw(requestParameters: LockExtensionControllerTriggerActionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.extensionId === null || requestParameters.extensionId === undefined) {
            throw new runtime.RequiredError('extensionId','Required parameter requestParameters.extensionId was null or undefined when calling lockExtensionControllerTriggerAction.');
        }

        if (requestParameters.lockId === null || requestParameters.lockId === undefined) {
            throw new runtime.RequiredError('lockId','Required parameter requestParameters.lockId was null or undefined when calling lockExtensionControllerTriggerAction.');
        }

        if (requestParameters.triggerExtensionActionDto === null || requestParameters.triggerExtensionActionDto === undefined) {
            throw new runtime.RequiredError('triggerExtensionActionDto','Required parameter requestParameters.triggerExtensionActionDto was null or undefined when calling lockExtensionControllerTriggerAction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }

        const response = await this.request({
            path: `/locks/{lockId}/extensions/{extensionId}/action`.replace(`{${"extensionId"}}`, encodeURIComponent(String(requestParameters.extensionId))).replace(`{${"lockId"}}`, encodeURIComponent(String(requestParameters.lockId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TriggerExtensionActionDtoToJSON(requestParameters.triggerExtensionActionDto),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Triggers an action in a lock extension
     * Trigger an action for a lock extension
     */
    async lockExtensionControllerTriggerAction(requestParameters: LockExtensionControllerTriggerActionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.lockExtensionControllerTriggerActionRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const LockControllerFindAllStatusEnum = {
    Active: 'active',
    Archived: 'archived',
    All: 'all'
} as const;
export type LockControllerFindAllStatusEnum = typeof LockControllerFindAllStatusEnum[keyof typeof LockControllerFindAllStatusEnum];
